---
marp: true
title: FP - 01 - Dise√±o Algor√≠tmico
author: Jaime Jes√∫s Delgado Meraz
header: Fundamentos de Programaci√≥n - U1
footer: '[&oast;](#contenidos) **DR. JJDM**'
paginate: true
theme: j2deme
math: mathjax
style: |
  :root {
    --primary: #1274c5;
    --secondary: #c22344;
  }
---
<!-- _class: centered -->
<!-- _paginate: false -->

# Unidad 1

# <!-- fit -->Dise√±o Algor√≠tmico

## Fundamentos de Programaci√≥n

<img class="logo" alt="TecNM" src="../src/assets/Logo-TECNM.svg" />

---

# Docente

![bg right:40%](../src/assets/banner.svg)

Nombre
: Dr. Jaime Jes√∫s Delgado Meraz

Correo
: <jesus.delgado@tecvalles.mx>
: <jaime.dm@cdvalles.tecnm.mx>

---

# Asignatura

:::: flex
::: col 1/2 px-2
Nombre
: Fundamentos de Programaci√≥n

Carrera
: Ingenier√≠a en Sistemas Computacionales
: Ingenier√≠a en Desarrollo de Aplicaciones
:::
::: col 1/2
Clave
: AED - 1285

SATCA
: 2 - 3 - 5
:::
::::

---
<!-- _class: toc -->
# Contenidos

1. [Conceptos b√°sicos](#conceptos-b√°sicos)
2. [Representaci√≥n de algoritmos](#representaci√≥n-de-algoritmos)
3. [Dise√±o de algoritmos](#dise√±o-de-algoritmos)
4. [Dise√±o de funciones](#dise√±o-de-funciones)

---

# Competencia espec√≠fica de la unidad

> Comprende y aplica los conceptos b√°sicos, nomenclatura y herramientas para el dise√±o de algoritmos orientado a la resoluci√≥n de problemas.

---

# Introducci√≥n

- Las computadoras son sorprendentemente r√°pidas, pero incre√≠blemente tontas, ya que pueden hacer cualquier cosa que se les indique, pero _exclusivamente_ eso.
- Para un ser humano una instrucci√≥n como "Lava los platos üßºüçΩ" no requiere mayor explicaci√≥n para ser desarrollada.
- Por otro lado, una computadora no puede tomar decisiones sobre una instrucci√≥n tan vaga, se le debe indicar exactamente que hacer para cada tipo de plato, vaso o utensilio.

---

# Introducci√≥n

- Es claro que los seres humanos somos buenos para ciertas tareas que las computadoras realizan pobremente, esto es debido a que los humanos somos buenos para extraer informaci√≥n de "ruido".
- Es decir, podemos entender instrucciones vagas y tomar decisiones basadas en informaci√≥n incompleta o ambigua.
- Sin embargo, una vez que las instrucciones son claras, las computadoras pueden realizarlas aprovechando todo el poder computacional disponible.
- En la idea anterior es que reside la importancia de la **programaci√≥n**.

---

<!-- _class: lead -->
# Conceptos b√°sicos

---

# Conceptos b√°sicos

- Para poder entender la programaci√≥n es necesario conocer algunos conceptos b√°sicos:
  - Algoritmo
  - Lenguaje de programaci√≥n
  - Programa
  - Compilador e int√©rprete
  - IDE (Entorno de Desarrollo Integrado)

---

# Conceptos b√°sicos

## Algoritmo

> Conjunto finito de instrucciones que se ejecutan en un orden determinado y para determinada situaci√≥n inicial resuelve un problema en un tiempo finito.

- Cormen, Leiserson, Rivest y Stein (2009) definen un algoritmo como **un procedimiento computacional que toma un valor o conjunto de valores como entrada y produce un valor o conjunto de valores como salida**.
- [Donald Knuth](https://es.wikipedia.org/wiki/Donald_Knuth) (_The Art of Computer Programming_) plantea una definici√≥n m√°s simple, diciendo que un algoritmo es **una secuencia finita de pasos que resuelve un problema**.

---

# Conceptos b√°sicos

## Algoritmo

De las definiciones anteriores, se puede establecer que un algoritmo debe ser:

- Claro, debe ser f√°cil de entender.
- Preciso, cada paso debe ser claramente definido.
- Finito, debe tener un n√∫mero finito de pasos.
- Efectivo, debe resolver el problema para el que fue dise√±ado.

Adem√°s, un algoritmo debe ser:

- Implementable en un lenguaje de programaci√≥n
- Independiente de donde se implemente <note>*</note>

<!--
La independencia de un algoritmo depender√° del contexto, ya que si bien, corresponde m√°s a la implementaci√≥n en un determinado lenguaje de programaci√≥n, que al algoritmo mismo, la indepedencia de este √∫ltimo, estar√° dada por las estructuras y estrategias aplicadas seg√∫n el lenguaje, sistema operativo y/o recursos t√©cnicos y tecnol√≥gicos disponibles.

Es decir, un algoritmo puede ser independiente de la plataforma, pero no de la implementaci√≥n.
-->

---

# Conceptos b√°sicos

## Lenguaje de programaci√≥n

> Conjunto de reglas sint√°cticas y sem√°nticas usadas para escribir programas que pueden ser ejecutados por una computadora.

- Un lenguaje de programaci√≥n es un conjunto de reglas que permiten a un programador escribir instrucciones que una computadora puede entender.
- De manera similar a los lenguajes humanos, cada lenguaje de programaci√≥n tiene su propia sintaxis, estructura, vocabulario, abreviaturas y reglas gramaticales.

---

# Conceptos b√°sicos

## Lenguaje de programaci√≥n

La descripci√≥n de un lenguaje de programaci√≥n se divide principalmente en 2 componentes.

:::: flex
::: col 1/2
Sintaxis (_Forma_)
: Es la forma en que se escriben las instrucciones en un lenguaje de programaci√≥n.
: Describe los s√≠mbolos y las combinaciones de los mismos, que forman un programa sint√°cticamente correcto.
:::

::: col 1/2
Sem√°ntica (_Significado_)
: Es el significado de las instrucciones escritas en un lenguaje de programaci√≥n.
: Provee las reglas para interpretar la sintaxis, limitando las posibles interpretaciones de lo que esta declarado.
:::
::::
  
---

# Lenguaje de programaci√≥n

## Ranking

| Posici√≥n 2024 | Posici√≥n 2023 | Delta | Lenguaje| Rating (%) | Delta (%) |
|:---:|:---:|:---:|:---|:---:|:---:|
| 1 | 1 | | ![Python h:35](../src/assets/Logos/Python.svg) Python | 16.12 | +2.70 |
| 2 | 3 | <true>&uarr;</true>| ![Cpp h:35](../src/assets/Logos/Cpp.svg) C++ | 10.34 | -0.46 |
| 3 | 2 | <false>&darr;</false>| ![C h:35](../src/assets/Logos/c.svg) C | 9.48 | -2.08 |
| 4 | 4 | | ![Java h:35](../src/assets/Logos/java.svg) Java| 8.59 | -1.91 |
| 5 | 5 | | ![C# h:35](../src/assets/Logos/C-sharp.svg) C# | 6.72 | -0.15 |

Tomado del [√çndice TIOBE](https://www.tiobe.com/tiobe-index/) (Julio, 2024).

---

# Conceptos b√°sicos

## Programa

> Conjunto de instrucciones que se ejecutan en una computadora para realizar una tarea espec√≠fica.

- Las instrucciones que componen un programa son escritas en un lenguaje de programaci√≥n y son interpretadas por un compilador o un int√©rprete.
- Un programa puede ser tan simple como una calculadora b√°sica o tan complejo como un sistema operativo.
- De igual manera, un programa puede componerse por un s√≥lo algoritmo o incluso ser un conjunto de algoritmos que resuelven un problema espec√≠fico.

---

# Conceptos b√°sicos

## Programa

Un programa suele tener dos formas:

- El **c√≥digo fuente** es la forma amigable para la lectura por humanos, de donde los programas ejecutables se derivan y permite que el programador los estudie y desarrolle sus propios algoritmos üë®üèª‚Äçüíª, esta escrito en un lenguaje de programaci√≥n.
- El **ejecutable** o _binario_ es la forma en que la computadora puede usar un programa para entender y ejecutar las instrucciones ü§ñ, puede ser c√≥digo binario o un lenguaje intermedio conocido como _bytecode_.

---

# Conceptos b√°sicos

## Compilador e Int√©rprete

- El c√≥digo fuente es la forma legible de un programa, el cual puede convertirse en una imagen ejecutable mediante un **compilador** o ejecutado inmediatamente con la ayuda de un  **int√©rprete**.
- Los compiladores se usan para traducir c√≥digo fuente de un lenguaje de programaci√≥n a lo que se conoce conm√∫nmente como ejecutables y/o binarios.
- Los compiladores son m√°s r√°pidos que los int√©rpretes, ya que traducen el c√≥digo fuente a un lenguaje de m√°quina antes de ejecutarlo, lo que permite que el programa se ejecute m√°s r√°pido.

---

# Conceptos b√°sicos

## Compilador e Int√©rprete

- Los int√©rpretes se usan para obtener una ejecuci√≥n inmediata del c√≥digo fuente y permitir su edici√≥n y reinterpretaci√≥n.
- El interpretado de c√≥digo es m√°s lento que ejecutar la versi√≥n compilada debido a que el int√©rprete debe decodificar cada instrucci√≥n una a la vez, sin embargo, el desarrollo de software se hace m√°s r√°pido usando un int√©rprete, ya que no es necesario compilar el c√≥digo cada vez que se realiza un cambio.
- Si bien, los compiladores e int√©rpretes son herramientas diferentes, es com√∫n encontrar lenguajes de programaci√≥n que usan ambos m√©todos.

---

# Conceptos b√°sicos

## Compilador e Int√©rprete

- Adem√°s de la traducci√≥n de c√≥digo fuente a ejecutable, los compiladores e int√©rpretes tambi√©n realizan tareas como:
  - Verificar la sintaxis y sem√°ntica del c√≥digo.
  - Optimizar el c√≥digo para mejorar su rendimiento.
- En algunos casos, un compilador puede ser un int√©rprete y viceversa, esto es conocido como **compilaci√≥n Just-In-Time (JIT)**, donde el c√≥digo fuente es compilado a un lenguaje intermedio que es interpretado por una m√°quina virtual.

---

# Conceptos b√°sicos

## IDE (Entorno de Desarrollo Integrado)

> Conjunto de herramientas que facilitan la creaci√≥n, edici√≥n, compilaci√≥n y depuraci√≥n de programas.

- Un IDE (_Integrated Development Environment_) es un software que combina varias herramientas de desarrollo en un solo paquete, permitiendo a los programadores escribir, compilar, depurar y ejecutar programas en un solo lugar.
- Suelen incluir un editor de texto, un compilador, un depurador, un navegador de archivos y un emulador de terminal.

---

# Conceptos b√°sicos

## IDE (Entorno de Desarrollo Integrado)

Algunos IDEs populares son:

- Visual Studio Code (VSCode)
- IntelliJ IDEA
- Eclipse
- NetBeans
- PyCharm
- Xcode
- Android Studio

---

# Resoluci√≥n de problemas

- Adem√°s de los conceptos b√°sicos revisados, tambi√©n es importante comprender como se resuelven los problemas mediante la programaci√≥n.
- Un programa se escribe en un lenguaje de programaci√≥n y a la actividad de expresar un algoritmo en forma de programa se le denomina **programaci√≥n**.
- La programaci√≥n es una actividad creativa que requiere de habilidades de resoluci√≥n de problemas y pensamiento l√≥gico.

---

# Resoluci√≥n de problemas

- La resoluci√≥n de problemas mediante programaci√≥n requiere al menos de los siguientes pasos:
  1. Definici√≥n del problema
  2. Dise√±o del algoritmo
  3. Transformaci√≥n del algoritmo en un programa
  4. Ejecuci√≥n y validaci√≥n del programa

---

# Resoluci√≥n de problemas

## Definici√≥n del problema

- El prop√≥sito de definir el problema es permitir al programador llegar a una cierta comprensi√≥n de la naturaleza del mismo.
- El problema debe estar bien definido si se quiere llegar a una soluci√≥n satisfactoria.
- Para poder definir con precisi√≥n el problema se requiere que las especificaciones de entrada y salida sean descritas en detalle.
- La correcta definici√≥n de estos requisitos, permitir√° llegar a una soluci√≥n eficaz.

---

# Resoluci√≥n de problemas

## Dise√±o del algoritmo

- Problemas complejos necesitan con frecuencia diferentes niveles de refinamiento antes de que se pueda obtener un algoritmo claro, preciso y completo.
- Lo recomendable es dividir del problema original en subproblemas m√°s simples y a continuaci√≥n dividir estos subproblemas en otros mas simples (_Divide & Conquer_).
- Debe existir una secuencia definida de pasos en la soluci√≥n propuesta, que permita obtener un resultado coherente.

---

# Resoluci√≥n de problemas

## Transformaci√≥n del algoritmo

- La fase de conversi√≥n del algoritmo en un lenguaje espec√≠fico de
  programaci√≥n se denomina **codificaci√≥n**, y el algoritmo resultante se denomina **c√≥digo fuente**.
- Durante la _transformaci√≥n_ del algoritmo, se debe considerar la sintaxis y sem√°ntica del lenguaje de programaci√≥n, as√≠ como las reglas de estilo y buenas pr√°cticas.
- As√≠ mismo, se debe considerar la eficiencia del algoritmo, ya que un algoritmo eficiente es aquel que resuelve el problema en el menor tiempo posible y con los recursos m√≠nimos necesarios.

---

# Resoluci√≥n de problemas

## Ejecuci√≥n y validaci√≥n del programa

- Una vez obtenido el c√≥digo fuente, la etapa de ejecuci√≥n y validaci√≥n del algoritmo suelen estar inmersas en el proceso de transformaci√≥n.
- Si el algoritmo fue dise√±ado correctamente, s√≥lo resta probar con los datos de entrada, de lo contrario, se deben realizar las modificaciones pertinentes hasta obtener el resultado esperado.
- La etapa de validaci√≥n es crucial para garantizar que el programa cumple con los requisitos del problema y que se comporta de manera esperada.

---

<!-- _class: lead -->
# Representaci√≥n de algoritmos

---

# Representaci√≥n de algoritmos

- Para poder representar un algoritmo de manera clara y precisa, es necesario utilizar un m√©todo que permita describir los pasos a seguir para resolver un problema.
- Se debe utilizar alg√∫n m√©todo que permita independizar el algoritmo del lenguaje de programaci√≥n elegido.
- La representaci√≥n de algoritmos es una tarea fundamental en la programaci√≥n, ya que permite a los programadores entender y comunicar de manera efectiva la soluci√≥n a un problema.

---

# Representaci√≥n de algoritmos

- Los m√©todos m√°s usuales son:
  - F√≥rmulas
  - Pseudoc√≥digo
  - Diagramas _Nassi-Schneiderman_
  - Diagramas de Flujo
  - Diagramas de Bloques

::: info
‚Ñπ Para motivos de la asignatura, se utilizar√° principalmente el **pseudoc√≥digo** y los **diagramas de flujo**.
:::

---
<!-- _class: primary centered -->
> _En igualdad de condiciones, la soluci√≥n m√°s simple suele ser la m√°s probable_
> <cite>William of Ockham</cite>

<!-- Tambi√©n conocido como el Principio de parsimonia -->

---

# Planteamiento de la soluci√≥n

- Es muy importante, que antes de empezar a teclear una "soluci√≥n" en la computadora, se dedique el tiempo de plantear correctamente la soluci√≥n al problema dado.
- Existen infinitas soluciones para cada uno de los problemas que puedan plantearse, pero siempre debemos encontrar la soluci√≥n m√°s adecuada, que sea la m√°s pr√°ctica y f√°cil de implementar.
- Siempre es importante considerar el principio de la simplicidad, tambi√©n conocido como la _Navaja de Ockham_.

---

# Planteamiento de la soluci√≥n

## Una an√©cdota

- Se comenta que durante la carrera espacial üöÄ entre Estados Unidos  y Rusia, la NASA invirti√≥ millones de dolares en la investigaci√≥n y desarrollo de un bol√≠grafo üñäÔ∏è que fuera capaz de escribir boca arriba en gravedad cero üë®‚ÄçüöÄ y en condiciones extremas de temperatura üî•
- Por su parte... Rusia utiliz√≥ l√°pices ‚úèÔ∏è

---

<!-- _class: primary centered -->
# Pseudoc√≥digo

---

# Pseudoc√≥digo

- El pseudoc√≥digo es un lenguaje de especificaci√≥n (descripci√≥n) de algoritmos, que permite pasar relativamente f√°cil hacia la codificaci√≥n final.
- Funciona como un borrador del algoritmo, que posteriormente se traduce al lenguaje de programaci√≥n que se requiera.
- La ventaja del pseudoc√≥digo reside en la planificaci√≥n de un programa, ya que el desarrollador se puede concentrar en la l√≥gica y en las estructuras de control, sin preocuparse por las reglas de un lenguaje espec√≠fico.
- Una ventaja adicional del pseudoc√≥digo es que permite tanto la modificaci√≥n r√°pida de operaciones, como la correcci√≥n de errores.

---

# Pseudoc√≥digo

El pseudoc√≥digo utiliza estructuras y sintaxis comunes, que estan disponibles igualmente est√°n disponibles en la mayor√≠a de los lenguajes de programaci√≥n.

:::: flex
::: col 1/2

- Variables y constantes
- Declaraci√≥n y asignaci√≥n
- Operadores
- Entrada y salida
:::
::: col 1/2
- Instrucciones de control
- Instrucciones de repetici√≥n
- Funciones
:::
::::

::: info
‚Ñπ Una alternativa al pseudoc√≥digo, son los lenguajes "regionalizados" como **Latino** (<https://www.lenguajelatino.org/>).
:::

---

# Pseudoc√≥digo

## Variables y constantes

> Una variable es un espacio de memoria que se utiliza para almacenar un valor. üß†

- Se utilizan para almacenar valores que se utilizan en un programa, como n√∫meros, texto, etc. y su valor esta determinado por el tipo de variable.
- Las variables se pueden utilizar para realizar operaciones, generalmente aritm√©ticas, a trav√©s del uso de **operadores**.
- Pes√© a su nombre, si se requiere, una variable puede definirse como constante, para evitar que su valor cambie durante la ejecuci√≥n del programa.

---

# Pseudoc√≥digo

## Variables y constantes

:::: flex
::: col 1/2
Variables
: Son objetos de programaci√≥n en los que su contenido puede variar durante el proceso de ejecuci√≥n del algoritmo, tienen un nombre y un tipo.
:::
::: col 1/2
Constantes
: Son objetos de programaci√≥n que permanecen sin cambios durante todo el desarrollo del algoritmo, en esencia son **variables** que no cambian.
:::
::::

::: warning
‚ö†Ô∏è Variables y constantes deben ser declaradas antes de ser utilizadas, as√≠ mismo, los nombres de las constantes suelen ser en **may√∫sculas**.
:::

---

# Pseudoc√≥digo

## Variables y constantes

- En pseudoc√≥digo la definici√≥n de variables suele seguir la siguiente forma:

```python
VAR nombre = valor : tipo de dato
CONST NOMBRE = valor : tipo de dato # Para las constantes
```

- Dependiendo del lenguaje de programaci√≥n pueden existir diferentes tipos de variables y puede ser requerido o no, el especificar el tipo de variable al definirla, ya que algunos lenguajes _inferir√°n_ el tipo de variable.
- Si bien las variables se pueden declarar en cualquier punto del programa, es una buena pr√°ctica el hacerlo al inicio del mismo.

---

# Pseudoc√≥digo

## Variables y constantes

### Tipos de datos

| Tipo | Descripci√≥n | Python | Java | Pseudoc√≥digo |
| :--- | :--- | :--- | :--- | :--- |
| Entero | N√∫mero entero (2024 / -42 ) | ```int``` | ```int``` | `entero` |
| Real | N√∫mero real (3.14159)| ```float``` | ```float``` | `decimal` |
| Texto | Cadena de caracteres (```"Hola"```) | ```str``` | ```String``` | `texto` |
| Booleano | Valor l√≥gico (<true>True</true> / <False>False</False>) | ```bool``` | ```boolean``` | `booleano` |
| Caracter | Caracter (`'A'`) | ```char``` | ```char``` | `caracter` |

---

# Pseudoc√≥digo

## Variables y constantes

### Nomenclatura

- Algo muy recomendable a la hora de programar es nombrar a las variables (y constantes) con un nombre significativo que manifieste su contenido, para mejorar su legibilidad.
  - _P.e._ si se quiere almacenar un d√≠a del mes, esa variable se podr√≠a llamarse `dia` o si se quisiera almacenar el total de la suma de varios productos, se podr√≠a usar `precio_final`.
- Es recomendable no usar espacios en blanco en los nombres de las variables o constantes, de la misma manera, se sugiere no utilizar acentos ni caracteres especiales, exceptuando el gui√≥n bajo.

---

# Pseudoc√≥digo

## Variables y constantes

### Nomenclatura

Existen diversas convenciones para nombrar las variables:

- üÖøÔ∏è **Pascal case**, todas las palabras inician con may√∫sculas, unidas sin espacios: `PrecioFinal`
- üê´ **Camel case**, inicia en min√∫scula, las palabras se unen usando may√∫sculas sin espacios a partir de la 2a palabra: `precioFinal`
- üêç **Snake case**, todas las palabras en min√∫scula, unidas por gui√≥n bajo: `precio_final`
- üç° **Kebab case**, todas las palabras en min√∫scula, unidas por gui√≥n medio: `precio-final`

---

# Pseudoc√≥digo

## Variables y constantes

### Nomenclatura

Si bien cada desarrollador puede elegir la convenci√≥n que m√°s le agrade, es importante recordar que en algunos casos, la convenci√≥n de nombres, depender√° del lenguaje de programaci√≥n.

_P.e. Java..._

- Los nombres de clase deben estar en **Pascal case**.
- Los nombres de variables deben estar en **Camel case**.
- Los nombres de constantes deben estar en **Snake case** en may√∫sculas, conocido como _Screaming Snake case_.

---

# Pseudoc√≥digo

## Declaraci√≥n y asignaci√≥n

- En el pseudoc√≥digo, la asignaci√≥n de valores a variables se realiza mediante el operador de asignaci√≥n `=` y se puede realizar en la misma l√≠nea de la declaraci√≥n o en l√≠neas separadas.

```python
VAR edad = 37 : entero # Podr√≠a omitirse el tipo de dato
VAR peso : decimal
peso = 70.5
```

- La asignaci√≥n de valores a variables se puede realizar de manera directa o a trav√©s de operaciones aritm√©ticas, l√≥gicas o de comparaci√≥n.

---

# Pseudoc√≥digo

## Declaraci√≥n y asignaci√≥n

:::: flex
::: col 1/2 px-2

### Java

```java
int edad = 37;
float peso = 70.5;
String nombre = "Jaime";
const float PI = 3.14159;
```

:::
::: col 1/2

### Python

```python
edad = 37
peso = 70.5
nombre = "Jaime"
PI = 3.14159
```

:::
::::

- Dependiendo del lenguaje de programaci√≥n, la asignaci√≥n de valores a variables puede variar, requiriendo especificar el tipo de dato o no.
- Estos ejemplos muestran, la diferencia entre un lenguaje de tipado fijo y uno de tipado din√°mico.

---

<!-- _class: inverted -->
# _Duck typing_ ü¶Ü

> "Si camina como un pato y suena como un pato, entonces debe ser un pato."

- Cuando se dice que un lenguaje de programaci√≥n _infiere_ el tipo de una variable es porque se aplica un estilo de tipado conocido como [_duck typing_](https://es.wikipedia.org/wiki/Duck_typing).
- En palabras m√°s simples, si se puede sumar, restar, multiplicar o dividir, entonces es un n√∫mero, si se puede concatenar, entonces es una cadena de caracteres, etc.
- Haciendo alusi√≥n a un contexto m√°s coloquial, _si huele a pollo, sabe a pollo, entonces es de pollo_ üê•

---

# Pseudoc√≥digo

## Variables especiales

- Existen ciertas variables **especiales** que se usan para ciertas funciones, estas variables pueden ser:
  - Contadores
  - Acumuladores
  - Interruptores (_Switches_)

---

# Pseudoc√≥digo

## Variables especiales

### Contadores

- Se utilizan para contar cualquier suceso dentro de un algoritmo y se realizan en dos instrucciones:
  1. **Inicializaci√≥n**, se suele inicializar en `0` si realiza una cuenta natural o desde un valor inicial, si queremos realizar otro tipo de cuenta.
  2. **Incremento**, se aumenta el valor de la variable en `1` si es una cuenta
  natural o con otro valor, si se desea realizar otro tipo de cuenta.

```python
VAR contador : entero
contador = 0
contador = contador + 1 # 1
contador++ # 2
# contador++ es equivalente a contador = contador + 1
```

---

# Pseudoc√≥digo

## Variables especiales

### Acumuladores

- Se utilizan para acumular resultados parciales de c√°lculos y se realizan en dos instrucciones:
  1. **Inicializaci√≥n**, se inicia con un valor neutro seg√∫n el tipo de operaci√≥n que se realiza, si es una suma se inicializar√° en `0` y si es un
  producto se inicializar√° en `1`.
  2. **Acumulaci√≥n**, se realiza la acumulaci√≥n seg√∫n el tipo de operaci√≥n.

```python
VAR acumulador: entero
acumulador = 0
acumulador = acumulador + 4 # acumulador += 4
acumulador = acumulador * 5 # acumulador *= 5
```

---

# Pseudoc√≥digo

## Variables especiales

### Interruptores

- Se utilizan para transmitir informaci√≥n de un punto a otro dentro del algoritmo, suelen combinarse con los ciclos y las estructuras de control.
- Solo deben tomar dos valores seg√∫n su tipo:
  - **Num√©ricos** puede ser `0` y `1`.
  - **L√≥gicos** pueder ser <true>true</true> o <false>false</false>.

```python
VAR interruptor: booleano
interruptor = false
# Suceso que cambia el estado del interruptor
interruptor = true
```

::: info
‚Ñπ Tambi√©n se les conoce como _banderas_ o _flags_.
:::

---

# Pseudoc√≥digo

## Operadores

> Un operador es un s√≠mbolo que representa una operaci√≥n que se realiza sobre uno o m√°s valores.

- En general, es posible distinguir entre los siguientes tipos de operadores:
  - Operadores aritm√©ticos
  - Operadores l√≥gicos
  - Operadores de comparaci√≥n

---

# Pseudoc√≥digo

## Operadores aritm√©ticos

:::: flex
::: col 1/2 px-2

- Este tipo de operadores se utilizan para realizar operaciones aritm√©ticas b√°sicas sobre valores num√©ricos, tal cual en las matem√°ticas.

:::
::: col 1/2 px-2

|Operador|Significado|Ejemplo|
|:---:|---|:---:|
|+  |Suma | 3 + 2 = 5|
|-  |Resta| 3 - 2 = 1|
|*  |Multiplicaci√≥n| 3 * 2 = 6|
|/  |Divisi√≥n | 3 / 2 = 1.5|
|%  |M√≥dulo   | 3 % 2 = 1|
|** |Potencia | 3 ** 2 = 9|

:::
::::

::: ok
‚úÖ El uso de par√©ntesis aplica de la misma manera que en las matem√°ticas.
:::

---

# Pseudoc√≥digo

## Operadores aritm√©ticos

### Ejemplo

```python
VAR a = 10 : entero
VAR b = 3 : entero
VAR c, d, e, f, g, h : entero
c = a + b
d = a - b
e = a * b
f = a / b
g = a % b
h = a ** b
```

- Si se requieren operaciones m√°s complejas, es posible utilizar funciones matem√°ticas, como las que se encuentran en la librer√≠a ```math``` de la mayor√≠a de los lenguajes de programaci√≥n.

---

# Pseudoc√≥digo

## Operadores aritm√©ticos

### Ejercicio

:::: flex
::: col 1/2 px-2

```python
VAR a = 5 : entero
VAR b = 7 : entero
VAR c = 2 : entero
a = a + b + c
b = c / 2
a = a / b + a * c
c = a + (b - c) - b
```

:::
::: col 1/2 px-2

- ¬øQu√© valor tiene `a` al finalizar la l√≠nea 4?
- ¬øQu√© valor tiene `b` al finalizar la l√≠nea 5?
- ¬øQu√© valor tiene `a` al finalizar la l√≠nea 6?
- ¬øQu√© valor tiene `c` al finalizar la l√≠nea 7?
:::
::::

---

# Pseudoc√≥digo

## Operadores l√≥gicos

- Los operadores l√≥gicos se utilizan para realizar operaciones l√≥gicas entre valores booleanos, las cuales pueden ser conjunci√≥n, disyunci√≥n o negaci√≥n y su resultado es un valor booleano.

|Operador| S√≠mbolo | Significado| Ejemplo |
|:---:|:---:|---|:---:|
|``and``| `&&` |Conjunci√≥n| ``True and False = False``|
|``or`` | `\|\|` |Disyunci√≥n| ``True or False = True``|
|``not``| `!` |Negaci√≥n   | ``not True = False``|

- En algunos lenguajes de programaci√≥n, los operadores l√≥gicos se representan con palabras en lugar de s√≠mbolos.

---

# Pseudoc√≥digo

## Operadores l√≥gicos

### Ejemplo

```python
VAR a = True : booleano
VAR b = False : booleano
VAR c, d, e : booleano

c = a and b # ALT: a && b
d = a or b  # ALT: a || b
e = not a   # ALT: !a
```

---

# Pseudoc√≥digo

## Operadores de comparaci√≥n

:::: flex
::: col 1/2 px-2

- Como su nombre lo indica, los operadores de comparaci√≥n se utilizan para comparar dos valores y su resultado es un valor booleano.

:::
::: col 1/2 px-2

|Operador|Significado|
|:---:|---|
|``==``|Igualdad|
|``!=``|Desigualdad|
|``>``|Mayor que|
|``<``|Menor que|
|``>=``|Mayor o igual que|
|``<=``|Menor o igual que|

:::
::::

---

# Pseudoc√≥digo

## Operadores de comparaci√≥n

### Ejemplo

```python
VAR a = 10 : entero
VAR b = 3 : entero
VAR c, d, e, f, g, h : entero
c = a == b
d = a != b
e = a > b
f = a < b
g = a >= b
h = a <= b
```

- Los operadores de comparaci√≥n se suelen usar en estructuras de control para evaluar condiciones y decidir si se ejecuta o no un bloque de instrucciones.

---

# Pseudoc√≥digo

## Operadores de comparaci√≥n

### Tabla de Verdad

- Para comprender mejor el funcionamiento de los operadores l√≥gicos y de comparaci√≥n, se puede utilizar una tabla de verdad, la cual muestra el resultado de aplicar un operador l√≥gico a dos valores booleanos.

|a  |b  | a AND b | a OR b |NOT (a)|
|:---:|:---:|:---:|:---:|:---:|
|<true>true</true>  |<true>true</true>  |<true>true</true>  |<true>true</true>  |<false>false</false>  |
|<true>true</true>  |<false>false</false>  |<false>false</false>  |<true>true</true>  |<false>false</false>  |
|<false>false</false>  |<true>true</true>  |<false>false</false>  |<true>true</true>  |<true>true</true>  |
|<false>false</false>  |<false>false</false>  |<false>false</false>  |<false>false</false>  |<true>true</true>  |

---

# Pseudoc√≥digo

## Entrada y salida

- La entrada y salida de datos es una parte fundamental de cualquier programa, ya que permite interactuar con el usuario y obtener los datos necesarios para resolver un problema.
- La entrada de datos se suele realizar a trav√©s de un teclado ‚å®, mientras que la salida a la consola o pantalla.
- En algunos casos m√°s complejos, la entrada y salida de datos se realiza a trav√©s de archivos.

---

# Pseudoc√≥digo

## Entrada y salida

- Las instrucciones para entrada y salida de datos se suelen representar de la siguiente manera:

```python
# 'variable' debe haber sido declarada previamente
LEER variable
ESCRIBIR variable
```

- Es una buena pr√°ctica el indicar con un mensaje descriptivo, el dato que se espera al momeno de leer:

```python
VAR nombre : texto
ESCRIBIR "¬øC√≥mo te llamas?"
LEER nombre
ESCRIBIR "Hola", nombre
```

---

# Pseudoc√≥digo

## Entrada y salida

### Entrada avanzada

- Cuando se requiere leer datos de un tipo espec√≠fico, se realiza un **casting** para convertir el valor le√≠do al tipo de dato que se requiere.
- Para esos casos, la sintaxis del operador ``LEER`` cambia ligeramente:

```python
LEER variable : tipo de dato
```

```python
VAR edad : entero
ESCRIBIR "¬øCu√°ntos a√±os tienes?"
LEER edad : entero
ESCRIBIR "El doble de tu edad es", (edad * 2)
```

- Sino se hiciera el casting a entero, la operaci√≥n `edad * 2` generar√≠a un error.

---

# Pseudoc√≥digo

## Entrada y salida

### Salida avanzada

- Cuando se requiere ESCRIBIR un mensaje con un formato espec√≠fico, es necesario especificar el formato de salida, utilizando algunos s√≠mbolos denominados **formateadores**.

```python
ESCRIBIR "Tu edad es {} a√±os.", edad
ESCRIBIR "Tu peso es: {:.2f}", peso
```

- Tambi√©n se pueden formatear n√∫meros enteros con una cierta estructura, separadores de miles, etc.

```python
ESCRIBIR "El folio es: {:0000d}", 123 # 0123
ESCRIBIR "El saldo es: ${:,.2f}", 1234567.89 # $1,234,567.89
```

---

# Pseudoc√≥digo

## Instrucciones de control

> Las estructuras de control son instrucciones que permiten modificar el flujo de ejecuci√≥n de un programa.

- Estas instrucciones permiten decidir si se ejecuta o no un bloque de instrucciones, tambi√©n se les conoce como condicionales.
- Se usan para que los programas "tomen decisiones" y realicen diferentes acciones dependiendo de las condiciones que se cumplan.
- Se suelen combinar con los operadores l√≥gicos y de comparaci√≥n para evaluar condiciones y decidir si se ejecuta o no un bloque de instrucciones.

---

# Pseudoc√≥digo

## Instrucciones de control

- Este tipo de instrucciones se basan en condiciones, las cuales son expresiones l√≥gicas que devuelven <true>true</true> o <false>false</false>, combinando los operadores l√≥gicos y de comparaci√≥n.
- Se pueden clasificar seg√∫n su estructura en:
  - Condicional simple
  - Condicional doble
  - Condicional m√∫ltiple
  - Condicional por casos

---

# Pseudoc√≥digo

## Instrucciones de control

### Condicional simple

- Si la condici√≥n espec√≠ficada se cumple, ejecuta el c√≥digo dentro del bloque.

:::: flex
::: col 1/3 px-2

```python
SI condici√≥n:
  Instrucciones
FIN-SI
```

:::
::: col 2/3 px-2

```python
INICIO
  VAR numero : entero
  LEER numero : entero
  SI numero < 10:
    ESCRIBIR "{} es menor que 10", numero
  FIN-SI
FIN
```

:::
::::

---

# Pseudoc√≥digo

## Instrucciones de control

### Condicional doble

- Si la condici√≥n es verdadera se ejecuta el bloque de instrucciones que contenga, de lo contrario se ejecuta el segundo bloque.

:::: flex
::: col 1/3 px-2

```python
SI condici√≥n:
  Instrucciones
SINO:
  Instrucciones
FIN-SI
```

:::
::: col 2/3 px-2

```python
INICIO
  VAR numero : entero
  LEER numero : entero
  SI numero < 10: 
    ESCRIBIR "{} es menor que 10", numero
  SINO:
    ESCRIBIR "{} es mayor o igual que 10", numero
  FIN-SI
FIN
```

:::
::::

---

# Pseudoc√≥digo

## Instrucciones de control

### Condicional m√∫ltiple

- Si se requiere, es posible construir condicionales con m√°s de una condici√≥n _combinando_ üß¨, _encadenando_ üîó o _anidando_ üê£ varios bloques.
- Para **combinar** condiciones se utilizan los operadores l√≥gicos `and` y `or`.

```python
SI edad <= 18 and gusta_anime == True:
  ESCRIBIR "Chibi Otaku"
SINO:
  ESCRIBIR "Adulto Otaku"
FIN-SI
```

---

# Pseudoc√≥digo

## Instrucciones de control

### Condicional m√∫ltiple

- Para **encadenar** condicionales, se deben combinar condicionales simples y dobles.

```python
SI edad < 18:
  ESCRIBIR "Eres menor de edad."
SINO SI edad == 18:
  ESCRIBIR "Bienvenido al mundo adulto üòÑ!"
SINO:
  ESCRIBIR "Eres mayor de edad."
FIN-SI
```

---

# Pseudoc√≥digo

## Instrucciones de control

### Condicional m√∫ltiple

- En algunas situaciones es posible que se requiera que se cumpla una condici√≥n, antes de revisar otras condiciones, en estos casos, lo que se suele hacer es anidar estructuras `SI`, para especificar m√°s de una condici√≥n.

```python
SI es_vegetariano == True:
  SI con_picante == True:
    ESCRIBIR "Tu pizza ser√° de champi√±ones con pimiento"
  SINO:
    ESCRIBIR "Tu pizza ser√° de champi√±ones con pi√±a"
  FIN-SI
SINO:
  ESCRIBIR "Tu pizza ser√° de carnes fr√≠as"
FIN-SI
```

---

# Pseudoc√≥digo

## Instrucciones de control

### Condicional por casos

- Existe otra instrucci√≥n de control condicional, denominada `SEGUN`, donde de acuerdo con el valor de una variable, se hace una operaci√≥n u otra.
- Para esta condicional no se utilizan expresiones l√≥gicas sino "casos".

:::: flex
::: col 1/2 px-2

```python
SEGUN valor:
  CASO valor1:
    Instrucciones
    ALTO
  CASO valor2:
    Instrucciones
    ALTO
    ...
  DEFAULT:
    Instrucciones
FIN-SEGUN
```

:::
::: col 1/2 px-2

```python
SEGUN valor:
  CASO valor1: Instrucci√≥n
  CASO valor2: Instrucci√≥n
    ...
  DEFAULT: Instrucci√≥n
FIN-SEGUN
```

- En los casos simples se puede omitir la instrucci√≥n `ALTO`.

:::
::::

---

# Pseudoc√≥digo

## Instrucciones de control

### Condicional por casos

:::: flex
::: col 1/2 px-2

```python
INICIO
  VAR mes : entero
  LEER mes
  SEGUN mes:
    CASO 1: ESCRIBIR "Enero"
    CASO 2: ESCRIBIR "Febrero"
    CASO 3: ESCRIBIR "Marzo"
    CASO 4: ESCRIBIR "Abril"
    CASO 5: ESCRIBIR "Mayo"
    ...
    CASO 11: ESCRIBIR "Noviembre"
    CASO 12: ESCRIBIR "Diciembre"
  FIN-SEGUN
FIN
```

:::
::: col 1/2 px-2

```python
INICIO
  VAR dia : entero
  LEER dia
  SEGUN dia:
    CASO 1: ESCRIBIR "Lunes"
    CASO 2: ESCRIBIR "Martes"
    CASO 3: ESCRIBIR "Mi√©rcoles"
    CASO 4: ESCRIBIR "Jueves"
    CASO 5: ESCRIBIR "Viernes"
    DEFAULT:
      ESCRIBIR "Fin de semana üéâ"
  FIN-SEGUN
FIN
```

:::
::::

---

# Pseudoc√≥digo

## Instrucciones de repetici√≥n

> Son instrucciones que permiten repetir un bloque de instrucciones un n√∫mero determinado de veces.

- Son muy √∫tiles para realizar c√°lculos repetitivos, como sumas, multiplicaciones, etc.
- Se pueden combinar con estructuras de control para realizar c√°lculos m√°s complejos, as√≠ como con variables para almacenar los resultados de los c√°lculos.
- Se conocen tambi√©n como _bucles_ o _ciclos_.

---

# Pseudoc√≥digo

## Instrucciones de repetici√≥n

- El n√∫mero de veces se determina mediante una condici√≥n, si la condici√≥n es verdadera se ejecuta el bloque de c√≥digo que contenga, cuando la condici√≥n sea falsa saldr√° del bucle üîÅ.
- Estas estructuras pueden ser del tipo:
  - Mientras
  - Hacer-mientras
  - Desde-hasta
  - Cada

---

# Pseudoc√≥digo

## Instrucciones de repetici√≥n

### Estructura "Mientras"

- Se eval√∫a la condici√≥n antes de iniciar y se repiten las instrucciones mientras siga siendo cierta.
- Es importante que la variable que participa en la condici√≥n se modifique dentro del bucle, ya que de lo contrario se genera un bucle infinito.
- Su sintaxis es:

```python
MIENTRAS condici√≥n:
  Instrucciones
  Instrucci√≥n que modifica la condici√≥n # ‚ùó Importante
  Instrucciones adicionales
FIN-MIENTRAS
```

---

# Pseudoc√≥digo

## Instrucciones de repetici√≥n

### Estructura "Mientras"

- En este caso se usa una variable `contador` que se ir√° incrementando dentro del bucle.

```python
INICIO
  VAR contador = 0 # Puede omitirse el tipo de dato
  MIENTRAS contador < 3:
    ESCRIBIR contador
    contador++ # contador = contador + 1
  FIN-MIENTRAS
FIN
```

- Como resultado se imprimen los n√∫meros del 0 al 2, ya que al cumplirse la condici√≥n `3 < 3` el resultado es <false>false</false> y termina el bucle.

---

# Pseudoc√≥digo

## Instrucciones de repetici√≥n

### Estructura "Hacer-Mientras"

- Es similar a la estructura `Mientras`, con la diferencia de realizar las instrucciones al menos una vez y luego eval√∫a la condici√≥n antes de continuar con el bucle.
- Al igual que con `MIENTRAS` se deben evitar los bucles infinitos.
- Su sintaxis es:

```python
HACER:
  Instrucciones
  Instrucci√≥n que modifica la condici√≥n # ‚ùó Importante
MIENTRAS condici√≥n
```

---

# Pseudoc√≥digo

## Instrucciones de repetici√≥n

### Estructura "Hacer-Mientras"

- En este caso se usa una variable `contador` que se ir√° incrementando dentro del bucle.

```python
INICIO
  VAR contador : entero
  contador = 3
  HACER:
    ESCRIBIR contador
    contador++ # contador = contador + 1
  MIENTRAS contador < 3
FIN
```

- Se imprime en pantalla el 3, enseguida sale del bucle dado que `4 < 3` es <false>false</false>.

---

# Pseudoc√≥digo

## Instrucciones de repetici√≥n

### Estructura "Desde-Hasta"

- En esta estructura se repiten las instrucciones desde una variable de control (`c`) a la que le damos un valor inicial (`i`) hasta un valor final (`f`) que se indique, increment√°ndose en un valor constante.
- Su sintaxis es:

```python
DESDE c=i HASTA f, 1:
  Instrucciones
FIN-DESDE
```

- El funcionamiento de esta estructura se basa en la expresi√≥n `c <= f`, incluyendo el valor final, si la constante es negativa, la condici√≥n cambia a `c >= f`.

---

# Pseudoc√≥digo

## Instrucciones de repetici√≥n

### Estructura "Desde-Hasta"

```python
INICIO
  VAR c : entero
  DESDE c=1 HASTA 5, 1:
    ESCRIBIR c
  FIN-DESDE
FIN
```

- La diferencia con la estructura `Mientras`, es que en el caso de `Mientras` se necesita inicializar la variable fuera del bucle y aumentarla dentro del bucle.
- En la estructura `Desde-Hasta`, la inicializaci√≥n y el incremento se hace en una l√≠nea.

---

# Pseudoc√≥digo

## Instrucciones de repetici√≥n

### Estructura "Cada"

- Los lenguajes de programaci√≥n modernos soportan una estructura de repetici√≥n adicional denominada `Cada`.
- Su sintaxis es:

```python
CADA sub_variable EN variable_agrupada:
  Instrucciones
FIN-CADA
```

- Su funcionamiento es parecido a la estructura `Desde-Hasta`, pero en lugar de incrementar una variable, se recorre cada elemento de una variable agrupada.

---

# Pseudoc√≥digo

## Instrucciones de repetici√≥n

### Estructura "Cada"

```python
INICIO
  VAR nombre : texto
  nombre = "Jaime"
  CADA letra EN nombre:
    ESCRIBIR letra
  FIN-CADA
FIN
```

- Dado que una cadena es un grupo de caracteres, es posible "recorrer" o **iterar** sobre ella y obtener cada elemento, en este ejemplo `"Jaime"` es equivalente a `['J','a','i','m','e']`.

---

# Pseudoc√≥digo

## Instrucciones de repetici√≥n

### Comparativa

Entonces ¬øQu√© estructura es mejor?

- La estructura `Desde-Hasta` es mejor cuando se conoce el rango, es
decir, el inicio y fin.
  - _P.e. sumar los n√∫meros del 1 al 20_
- Las estructuras `Mientras` y `Hacer-Mientras` son mejores en los casos donde no se conoce el final.
  - _P.e. sumar todos los n√∫meros que el usuario vaya ingresando, sin saber cuantos ser√°n_

---

# Pseudoc√≥digo

## Instrucciones de repetici√≥n

### Comparativa

- La estructura `Cada` se utiliza cuando se quiere trabajar con todos los datos de un grupo.
  - _P.e. sumar todos los n√∫meros de un arreglo de enteros_
- Otra diferencia en las estructuras `Mientras` y `Hacer-Mientras` es que su condici√≥n debe ser <true>true</true> para que entrar al bucle y <false>false</false> para salir.
- Finalmente, la decisi√≥n de que estructura usar puede variar de acuerdo al problema a resolver y a la experiencia del desarrollador.

---

# Pseudoc√≥digo

## Funciones

> Una funci√≥n es un bloque de c√≥digo que se puede ejecutar cuando se requiera, sin tener que escribir nuevamente el c√≥digo.

- Las funciones son muy √∫tiles cuando se requiere ejecutar un bloque de c√≥digo varias veces, los lenguajes de programaci√≥n modernos soportan el uso y dise√±o de funciones.
- Para utilizar estas funciones, se escribe el nombre de la funci√≥n y los par√°metros que se necesiten para funcionar.
- Un **par√°metro** es un valor que se le proporciona a una funci√≥n para que pueda funcionar.

---

# Pseudoc√≥digo

## Funciones

- Una funci√≥n puede recibir cero o m√°s par√°metros, dependiendo de lo que se requiera, por lo que es importante conocer los par√°metros que requiere cada funci√≥n, para obtener el resultado esperado.
- Com√∫nmente, el resultado de las funciones se debe almacenar en una variable, pero tambi√©n puede ser usado en una condici√≥n o impreso a pantalla.
- Las funciones pueden dividirse en tres tipos:
  - Funciones est√°ndar
  - Funciones avanzadas
  - Funciones del usuario (personalizadas)

---

# Pseudoc√≥digo

## Funciones est√°ndar

- Las funciones est√°ndar son aquellas que vienen incluidas en el n√∫cleo del lenguaje de programaci√≥n, por lo que no es necesario definirlas.
- Las funciones est√°ndar de los lenguajes de programaci√≥n suelen ser muy similares, incluyendo seg√∫n el lenguaje:
  - Instrucciones de entrada y salida
  - Instrucciones de control de flujo y repetici√≥n
  - Operaciones matem√°ticas b√°sicas
  - Operaciones con cadenas de texto

---

# Pseudoc√≥digo

## Funciones est√°ndar

### Entrada y salida

- Las funciones est√°ndar de entrada y salida son aquellas que permiten obtener datos del usuario y mostrar datos en pantalla.

| Funci√≥n | Descripci√≥n |Python| C++ | Java | JavaScript |
|---|---|---|---|---|---|
| ESCRIBIR | Muestra un mensaje en pantalla | ```print()``` | ```cout``` | ```System.out.println()``` | ```console.log()``` |
| LEER | Lee un valor desde el teclado | ```input()``` | ```cin``` | ```Scanner``` | ```prompt()``` |

---

# Pseudoc√≥digo

## Funciones est√°ndar

### Control de flujo y repetici√≥n

- Como ya se ha visto, las instrucciones de control de flujo y repetici√≥n son aquellas que permiten decidir si se ejecuta o no un bloque de instrucciones, o repetir un bloque de instrucciones un n√∫mero determinado de veces.
- Estas instrucciones son muy similares en todos los lenguajes de programaci√≥n, siendo en la mayor√≠a de los casos hom√≥nimas.
- Aunque no lo parezca, estas instrucciones son funciones est√°ndar del lenguaje.

---

# Pseudoc√≥digo

## Funciones est√°ndar

### Operaciones matem√°ticas b√°sicas

- Las funciones est√°ndar de operaciones matem√°ticas b√°sicas son aquellas que permiten realizar operaciones aritm√©ticas b√°sicas, como suma, resta, multiplicaci√≥n y divisi√≥n, y que a igual que otras funciones est√°ndar, suelen venir incluidas en el n√∫cleo del lenguaje de programaci√≥n.
- Estas funciones se representan con los s√≠mbolos matem√°ticos correspondientes, como ```+```, ```-```, ```*``` y ```/```.

---

# Pseudoc√≥digo

## Funciones est√°ndar

### Operaciones con cadenas de texto

- Este tipo de funciones est√°ndar son aquellas que permiten realizar operaciones con cadenas de texto, como concatenar cadenas de texto, obtener la longitud de una cadena, obtener una subcadena, etc.
- Dependiendo del lenguaje de programaci√≥n, estas funciones pueden estar incluidas en el n√∫cleo del lenguaje o pueden utilizadas como una **funci√≥n avanzada**, disponible como parte de una librer√≠a o m√≥dulo.

---

# Pseudoc√≥digo

## Funciones est√°ndar

### Operaciones con cadenas de texto

- Las funciones para texto m√°s comunes son:

| Funci√≥n | Descripci√≥n |
|---|---|
| LONG(s) | Longitud de la cadena `s` |
| LIMPIA(s)| Elimina espacios alrededor de la cadena `s` |
| EN(s, x)| Devuelve el caracter ubicado en la posici√≥n `x` de `s` |
| SUB(s, n)| Toma `n` caracteres de `s`, desde el inicio |
| MAYUS(s) | Convierte `s` a may√∫sculas |
| MINUS(s) | Convierte `s` a min√∫sculas |

---

# Pseudoc√≥digo

## Funciones avanzadas

:::: flex
::: col 1/2 px-2

- Las funciones avanzadas son aquellas que no vienen incluidas en el n√∫cleo del lenguaje de programaci√≥n.
- Pueden utilizarse importando una librer√≠a o m√≥dulo.

:::

::: col 1/2 px-2

- Entre la librer√≠as de funciones avanzadas m√°s comunes se encuentran:
  - Funciones matem√°ticas y trigonom√©tricas
  - Funciones con aleatorios
  - Funciones con fechas y horas
  - Funciones para manejo de archivos
:::
::::

---

# Pseudoc√≥digo

## Funciones avanzadas

### Funciones matem√°ticas

- Incluidas en el m√≥dulo ```math```.

| Funci√≥n | Descripci√≥n |
|---|---|
| SQRT(x)| Ra√≠z cuadrada de `x` |
| ABS(x) | Valor absoluto de `x`|
| MAX(x, y) | Valor m√°ximo entre `x` y `y`|
| MIN(x, y) | Valor m√≠nimo entre `x` y `y`|
| LOG(x) | Logaritmo natural de `x`|
| POW(x, y) | `x` elevado a la potencia `y`|

---

# Pseudoc√≥digo

## Funciones avanzadas

### Funciones matem√°ticas

- Incluidas en el m√≥dulo ```math```.

| Funci√≥n | Descripci√≥n |
|---|---|
| ROUND(x) | Entero m√°s cercano a `x`|
| CEIL(x) | Entero superior m√°s cercano a `x`|
| FLOOR(x)| Entero inferior m√°s cercano a `x`|
| TRUNC(x)| Entero m√°s cercano a `x`, sin redondear|
| FACT(x) | Factorial de `x`|
| PI | Valor de PI|

---

# Pseudoc√≥digo

## Funciones avanzadas

### Funciones trigonom√©tricas

- Incluidas en el m√≥dulo ```math```.

| Funci√≥n | Descripci√≥n |
|---|---|
| SIN(x) | Seno de `x`|
| COS(x) | Coseno de `x`|
| TAN(x) | Tangente de `x`|
| CTG(x) | Cotangente de `x`|
| SEC(x) | Secante de `x`|
| CSC(x) | Cosecante de `x`|

---

# Pseudoc√≥digo

## Funciones avanzadas

### Funciones con aleatorios

- Incluidas en el m√≥dulo ```random```.

| Funci√≥n | Descripci√≥n |
|---|---|
| RAND() | Aleatorio entre `0.0` y `1.0`|
| RAND(x) | Aleatorio entre `0` y `x`|
| RAND(x, y) | Aleatorio entre `x` y `y`|
| CHOICE(lista) | Aleatorio de la lista `lista`|
| SHUFFLE(lista) | Mezcla la lista `lista`|

---

# Pseudoc√≥digo

## Funciones de usuario

- Pr√°cticamente todos los lenguajes de programaci√≥n modernos soportan la construcci√≥n de funciones por parte del usuario para resolver necesidades que no esten implementadas de manera inicial.
- A estas funciones tambi√©n se les conoce como funciones **personalizadas**, el requisito principal es que estas funciones no tengan el mismo nombre que las funciones nativas del lenguaje.
- Pueden hacer uso de los operadores y funciones nativas del lenguaje e incluso usar otras funciones personalizadas.

---

# Pseudoc√≥digo

## Funciones de usuario

- Las funciones de usuario tienen como principal prop√≥sito reutilizar c√≥digo, ya que permiten ejecutar un bloque de instrucciones varias veces, sin tener que escribir nuevamente el c√≥digo.
- Permiten dividir un programa en bloques de instrucciones m√°s peque√±os, lo que facilita la lectura y comprensi√≥n del c√≥digo.
- Pueden tener diferentes formas (_signatures_), dependiendo de lo que se requiera.

---

# Pseudoc√≥digo

## Funciones de usuario

### Declaraci√≥n

- Generalmente las funciones de usuario se definen de la siguiente manera:

```python
# Los nombres de funciones siguen la misma regla que las variables
FUNCION funcion1():
  # Instrucciones
FIN-FUNCION
```

- Si la funci√≥n ocupa par√°metros, se deben indicar dentro de los par√©ntesis, indicando el tipo de dato que se espera:

```python
FUNCION funcion2(param1 : tipo, param2 : tipo):
  # Instrucciones
FIN-FUNCION
```

---

# Pseudoc√≥digo

## Funciones de usuario

### Retorno de valores

- En algunos casos, se requiere que las funciones regresen alg√∫n valor calculado dentro de la misma.
- Para ello se utiliza la palabra clave ``DEVUELVE``, adem√°s, se debe especificar el tipo de dato que se espera devolver.

```python
FUNCION funcion3(param1 : tipo, param2 : tipo): tipo
  # Instrucciones
  # P.e. valor = param1 + param2 
  DEVUELVE valor
FIN-FUNCION
```

---

# Pseudoc√≥digo

## Funciones de usuario

### Uso

- Para utilizar una funci√≥n de usuario, se escribe el nombre de la funci√≥n seguida con par√©ntesis, si la funci√≥n ocupa par√°metros, se deben indicar dentro de los par√©ntesis.

```python
funcion1() # No ocupa par√°metros y no devuelve un valor
funcion2(10, 5) # Ocupa par√°metros y no devuelve un valor

VAR resultado : entero # Se debe declarar la variable
resultado = funcion3(10, 5) # Ocupa par√°metros y devuelve un valor
```

::: warning
‚ö† El orden y tipo de los par√°metros deben coincidir con la definici√≥n de la funci√≥n.
:::

---

# Pseudoc√≥digo

## Funciones de usuario

### Funci√≥n flecha

- Una versi√≥n simplificada de las funciones de usuario, es la **funci√≥n flecha**, que permite definir funciones de manera m√°s compacta y sencilla.

```python
FUNCION funcion4(param1 : tipo, param2 : tipo): tipo => param1 + param2
```

- Son muy √∫tiles para funciones sencillas que devuelven valores y que no requieren de un bloque de instrucciones muy grande.

::: warning
‚ö† Aunque no todos los lenguajes de programaci√≥n soportan este tipo de funciones es importante conocerlas.
:::

---

# Pseudoc√≥digo

- En resumen, el pseudoc√≥digo es una herramienta que permite describir un algoritmo de manera detallada, sin tener que preocuparse por la sintaxis de un lenguaje de programaci√≥n en particular.
- Permite representar un algoritmo de manera clara y concisa, utilizando un lenguaje sencillo y cercano al lenguaje natural.
- Dependiendo de los autores, el pseudoc√≥digo puede variar en su estructura y sintaxis, pero en general sigue las mismas reglas y convenciones, lo importante es que sea f√°cil de entender y de seguir.

---

<!-- _class: primary centered -->
# Diagramas de flujo

---

# Diagramas de flujo

> Un diagrama de flujo es un tipo de diagrama que representa un algoritmo o proceso, mostrando los pasos en figuras diversas y estableciendo su orden conectandolos con flechas.

- Son una herramienta muy √∫til para representar de manera gr√°fica los pasos que se deben seguir para resolver un problema.
- Es una representaci√≥n gr√°fica muy popular, aunque no es la √∫nica, de hecho una alternativa moderna son los diagramas de bloques en lenguajes de programaci√≥n visuales como [Scratch](https://scratch.mit.edu/) üê±.

---

# Diagramas de flujo

- Los diagramas de flujo siguen una convenci√≥n visual definida por la [ISO 5807:1985](https://www.iso.org/es/contents/data/standard/01/19/11955.html) _Information processing ‚Äî Documentation symbols and conventions for data, program and system flowcharts, program network charts and system resources charts_, que reemplaza a la [ISO 1028:1973](https://www.iso.org/es/contents/data/standard/00/55/5500.html).
- Esta norma establece una serie de s√≠mbolos y convenciones para la construcci√≥n de diagramas de flujo y otros.

![bg right:40% fit](https://upload.wikimedia.org/wikipedia/commons/1/1b/IBM_flowchart_template.jpg)

---

# Diagramas de flujo

## Software

- Aunque es posible realizar diagramas de flujo a mano alzada o usando plantillas, existen herramientas especializadas para su creaci√≥n.
- Aplicaciones como [Excalidraw](https://excalidraw.com/) o [Draw.io](https://app.diagrams.net/) permiten crear diagramas de flujo de manera sencilla y r√°pida en l√≠nea.
- Tambi√©n existen aplicaciones de escritorio como [Lucidchart](https://www.lucidchart.com/pages/es) o [Microsoft Visio](https://www.microsoft.com/es-mx/microsoft-365/visio/flowchart-software) que permiten crear diagramas de flujo m√°s complejos.
- Una alternativa innovadora es [Flowgorithm](https://www.flowgorithm.org/), que permite crear diagramas de flujo interactivos y convertirlos en c√≥digo.

---

# Diagramas de flujo

De manera similar al pseudoc√≥digo, los diagramas de flujo siguen una serie de convenciones y reglas para su construcci√≥n y que abarcan al menos los siguientes elementos:

:::: flex
::: col 1/2

- Variables y constantes
- Declaraci√≥n y asignaci√≥n
- Operadores
- Entrada y salida
:::
::: col 1/2
- Instrucciones de control
- Instrucciones de repetici√≥n
- Funciones
:::
::::

::: warning
‚ö† Dependiendo de software o herramienta que se utilice, los s√≠mbolos y convenciones pueden variar ligeramente.
:::

---

# Diagramas de flujo

## Estructura b√°sica

- La estructura b√°sica de un diagrama de flujo se compone de las instrucciones `Inicio - Fin`.
- Estas palabras se representan con un √≥valo, con el texto correspondiente en su interior.
- En algunos casos se utiliza la palabra `Principal` en lugar de `Inicio`.

![bg fit right:40%](../src/assets/FP/flowcharts-ovals.svg)

---

# Diagramas de flujo

## Variables y constantes

- El uso de variables y constantes en los diagramas de flujo, sigue las mismas reglas que en el pseudoc√≥digo en cuanto a:
  - Nomenclatura
  - Tipos de datos
- La principal diferencia es la declaraci√≥n y asignaci√≥n de variables y constantes, son instrucciones que se representan de manera separada, a diferencia del pseudoc√≥digo, donde se puede tener declaraci√≥n y asignaci√≥n en una sola instrucci√≥n.

---

# Diagramas de flujo

## Declaraci√≥n de variables

- La declaraci√≥n de variables y constantes se realiza mediante un rect√°ngulo con doble borde en la parte superior e izquierda.
- Dentro de la figura se indica el tipo de dato, seguido del nombre de la variable.
- Aunque es posible utilizar un rect√°ngulo simple, esto puede causar confusi√≥n con otros s√≠mbolos.

![bg fit right:40%](../src/assets/FP/flowcharts-variables.svg)

---

# Diagramas de flujo

## Asignaci√≥n de variables

- La asignaci√≥n de variables se realiza mediante un rect√°ngulo simple, tambi√©n conocido como **proceso**.
- Dentro de la figura se indica el nombre de la variable, seguido del operador de asignaci√≥n `=`, y el valor que se le asigna.
- La asignaci√≥n tambi√©n puede ser resultado de una operaci√≥n.

![bg fit right:40%](../src/assets/FP/flowcharts-assignment.svg)

---

# Diagramas de flujo

## Operadores

- Los operadores aritm√©ticos, l√≥gicos y de comparaci√≥n se utilizan mediante bloques de proceso (rect√°ngulos simples).
- Estos operadores se representa mediante sus respectivos s√≠mbolos:
  - Los operadores aritm√©ticos se representan con los s√≠mbolos `+`, `-`, `*`, `/`, `++` y `--`.
  - Los operadores l√≥gicos se representan con los s√≠mbolos `&&`, `||` y `!`.
  - Los operadores de comparaci√≥n se representan con los s√≠mbolos `=`, `!=`, `<`, `>`, `<=` y `>=`.

---

# Diagramas de flujo

## Entrada

- La entrada de datos se representa mediante un paralelogramo, con la palabra `Leer` en su interior, seguida del nombre de la variable a la que se le asignar√° el valor.
- En algunos casos se utiliza la palabra `Entrada` en lugar de `Leer`.

![bg fit right:40%](../src/assets/FP/flowcharts-input.svg)

---

# Diagramas de flujo

## Salida

- La entrada de datos se representa mediante un paralelogramo, con la palabra `Escribir` en su interior, seguida del mensaje o variable que se desea mostrar en pantalla.
- En algunos casos se utiliza la palabra `Salida` en lugar de `Escribir`.

![bg fit right:40%](../src/assets/FP/flowcharts-output.svg)

---

# Diagramas de flujo

## Entrada y salida

- Algunas convenciones sugieren el uso de s√≠mbolos diferentes para la entrada y la salida, para evitar confusi√≥n.
- Para estos casos se utiliza un trapezoide invertido para la lectura y un trapezoide normal para la escritura.
- En ambos casos se omiten las palabras `Leer` y `Escribir`.

![bg fit right:40%](../src/assets/FP/flowcharts-io.svg)

---

# Diagramas de flujo

## Instrucciones de control

- Las instrucciones de control se representan con un rombo, con la condici√≥n en su interior.
- Es posible representar instrucciones de control simples y dobles, as√≠ como m√∫ltiples combinando varios rombos.
- Adicionalmente se despliegan las flechas de acuerdo a la condici√≥n.

![bg fit right:40%](../src/assets/FP/flowcharts-decision.svg)

---

# Diagramas de flujo

## Instrucciones de control

### Casos

- Para representar las instrucciones de control por casos, se usan un rombos con la palabra `Caso` en su interior.
- Se deben representar los casos posibles y las acciones a realizar en cada caso.

::: warning
‚ö† Se debe ser cuidadoso al representar los casos, ya que puede resultar confuso.
:::

![bg fit right:40%](../src/assets/FP/flowcharts-switch.svg)

---

# Diagramas de flujo

## Instrucciones de repetici√≥n

- Las instrucciones de control se representan con un hex√°gono irregular con el lado superior e inferior de mayor longitud.
- En el √°mbito de los diagramas de flujo, esta figura recibe el nombre de **preparaci√≥n**.
- Dentro de la figura se indica la condici√≥n de repetici√≥n.

![bg fit right:40%](../src/assets/FP/flowcharts-loops.svg)

---

![bg h:85%](../src/assets/FP/flowcharts-loops2.svg)

---

# Diagramas de flujo

## Funciones

- En el pseudoc√≥digo las funciones se representan en dos partes:
  1. La **llamada** o uso, mediante un rect√°ngulo con doble borde a la izquierda y derecha.
  2. La **definici√≥n**, mediante una estructura similar al `Inicio - Fin`, pero con el nombre de la funci√≥n y sus par√°metros.

![bg fit right:40%](../src/assets/FP/flowcharts-functions.svg)

---

# Diagramas de flujo

## Funciones

- Cuando se requieren pasar par√°metros se indican en la llamada.
- Si la funci√≥n devuelve un valor, se indica en el ovalo final con la palabra `Devuelve` y el nombre de la variable.

::: warning
‚ö† Algunos autores sugieren describir la funci√≥n a modo de prosa para evitar saturar el diagrama. _P.e._ ``sumar num1 y num2 y devolver el resultado``.
:::

![bg fit right:40%](../src/assets/FP/flowcharts-functions2.svg)

---

# Diagramas de flujo

- Los diagramas de flujo son una herramienta muy √∫til para representar algoritmos de manera gr√°fica, lo que facilita su comprensi√≥n y seguimiento.
- Dependiendo de la complejidad del algoritmo, los diagramas de flujo pueden representarse de manera macro o micro, priorizando la claridad y la legibilidad.
- En la pr√°ctica, los diagramas de flujo se utilizan para documentar algoritmos, para planificar la implementaci√≥n de un programa o para explicar un proceso a otras personas, sin necesidad de conocer un lenguaje de programaci√≥n en particular.

---

<!-- _class: lead -->
# Dise√±o de algoritmos

---

# Dise√±o de algoritmos

- El dise√±o de algoritmos es una parte fundamental de la programaci√≥n, ya que permite resolver problemas de manera eficiente y efectiva.
- Se basa en la aplicaci√≥n de t√©cnicas y estrategias para la resoluci√≥n de problemas, como la **descomposici√≥n** y la **abstracci√≥n**.
- En otras palabras, se trata de dividir un problema en partes m√°s peque√±as y f√°ciles de resolver, para luego combinarlas y obtener la soluci√≥n final.
- Un factor importante al dise√±ar un algoritmo soluci√≥n es la capacidad de analizar el problema y determinar la mejor estrategia para resolverlo.

---

# Dise√±o de algoritmos

- Al dise√±ar un algoritmo, es importante tener en cuenta los siguientes aspectos:
  - **Eficiencia**: El algoritmo resuelve un problema en el menor tiempo posible y con los recursos m√≠nimos.
  - **Claridad**: El algoritmo es f√°cil de entender y seguir, tanto para el programador como para otras personas.
  - **Robustez**: El algoritmo es capaz de manejar situaciones inesperadas o errores sin fallar.
  - **Escalabilidad**: El algoritmo es aquel que puede manejar grandes vol√∫menes de datos sin perder eficiencia.

---

# Dise√±o de algoritmos

## Planteamiento

- Para empezar el an√°lisis del problema, lo primero que se debe hacer es leer atentamente el problema y extraer lo m√°s importante, omitiendo detalles irrelevantes o extras.
- Una estrategia para extraer lo m√°s importante del problema es realizar una serie de preguntas y tratar de responderlas.
- Aunque esta estrategia no es infalible, puede ayudar a entender el problema y a plantear una soluci√≥n.

---

# Dise√±o de algoritmos

## Planteamiento

- ¬øEl usuario debe introducir alg√∫n tipo de dato?
- Si el usuario no ingresa datos ¬øSe debe tener alg√∫n definido previamente?
- ¬øHay alguna instrucci√≥n que deba repetirse en el algoritmo?
- ¬øHay alguna instrucci√≥n que dependa de alguna condici√≥n para realizarse?
- Si se tiene alguna condicional
  - ¬øSe debe hacer algo si no se cumple?
  - ¬øEsta depende de alguna anterior?
  - ¬øLa condici√≥n es simple o compuesta?

---

# Dise√±o de algoritmos

## Planteamiento

- Si se debe repetir algo
  - ¬øSe conoce el inicio y el fin o solo el inicio?
  - ¬øCuando debe detenerse? (Condici√≥n de salida)
- Si hay condicionales o repeticiones ¬øCu√°l es la condici√≥n o condiciones apropiadas?
- ¬øQu√© variables necesita el algoritmo?
- ¬øDe que tipo son la variables que se necesitan?
- ¬øCon que valor deben iniciar las variables?

---

# Dise√±o de algoritmos

## Planteamiento

- ¬øSe necesita mostrar algo en pantalla?
- Si se tiene que mostrar algo
  - ¬øQu√© resultado o resultados se necesitan?
  - ¬øEn que orden o formato se deben mostrar?
- ¬øHay alg√∫n conjunto de instrucciones que se repita en diferentes partes del algoritmo?

---

# Dise√±o de algoritmos

## Problema 1

### Descripci√≥n

> Un vendedor recibe un sueldo base, m√°s un 10% extra por comisi√≥n de sus ventas, el vendedor desea saber cuanto dinero obtendr√° por concepto de comisiones por las tres ventas que ha realizado este mes, y el total que recibir√°.

---

# Dise√±o de algoritmos

## Problema 1

### Soluci√≥n propuesta

```python
INICIO
  VAR contador, SALARIO_BASE : entero
  VAR venta, total, COMISION : decimal
  SALARIO_BASE = 1000
  COMISION = 0.1
  total = venta = 0
  DESDE contador=1 HASTA 3, 1:
    ESCRIBIR "Ingresa la venta n√∫mero {}: ", contador
    LEER venta
    total = total + (venta * COMISION)
  FIN-DESDE
  total = SALARIO_BASE + total
  ESCRIBIR "Este mes el vendedor gan√≥ ${:.2f}", total
FIN
```

---

# Dise√±o de algoritmos

## Problema 2

### Descripci√≥n

> Escriba un algoritmo que determine cuales son los m√∫ltiplos de 5, comprendidos entre 1 y N.

---

# Dise√±o de algoritmos

## Problema 2

### Soluci√≥n propuesta

```python
INICIO
  VAR n, num : entero
  ESCRIBIR "N√∫mero m√°ximo:"
  LEER n
  ESCRIBIR "Los m√∫ltiplos de 5 entre 1 y {} son:", n
  DESDE num=1 HASTA n, 1:
    SI num % 5 == 0:
      ESCRIBIR num
    FIN-SI
  FIN-DESDE
FIN
```

---

<!-- _class: lead -->
# Dise√±o de funciones

---

# Dise√±o de funciones

- El dise√±o de funciones es una parte fundamental de la programaci√≥n, ya que permite reutilizar c√≥digo y dividir un programa en bloques m√°s peque√±os y f√°ciles de entender.
- Una funci√≥n es un bloque de c√≥digo que se puede ejecutar cuando se requiera, sin tener que escribir nuevamente el c√≥digo.
- Se debe tomar en cuenta que la mayor√≠a de los lenguajes de programaci√≥n modernos incluyen un amplio conjunto de funciones est√°ndar altamente optimizadas y eficientes.
- Por lo anterior, es importante revisar si existe una funci√≥n est√°ndar que resuelva el problema antes de dise√±ar una funci√≥n personalizada.

---

# Dise√±o de funciones

- Al dise√±ar una funci√≥n, es importante tener en cuenta los siguientes aspectos:
  - **Claridad**: Es f√°cil de entender y seguir, tanto para el programador como para otras personas.
  - **Reutilizaci√≥n**: Puede ser utilizada en diferentes partes del programa, sin tener que reescribir el c√≥digo.
  - **Eficiencia**: Resuelve el problema de manera eficiente y efectiva.
- Es importante analizar el subproblema que se busca resolver y determinar la mejor estrategia de soluci√≥n.
- Una funci√≥n podr√° ser tan simple como sumar dos n√∫meros o tan compleja como resolver un problema matem√°tico avanzado.

---

<!-- _class: inverted centered -->
![bg right w:35%](../src/assets/avatar.png)

<div class="text-center text-middle font-bold font-coding text-8xl mt-10">
  &lt;/Fin&gt;
</div>

---

<!-- paginate: skip -->

# Referencias I

- Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C. (2009). _Introduction to Algorithms_ (3rd ed.). MIT Press.
- Knuth, D. E. (1997). _The Art of Computer Programming_ (Vol. 1). Addison-Wesley.
- Wikipedia. (2024). _Donald Knuth_. [https://es.wikipedia.org/wiki/Donald_Knuth](https://es.wikipedia.org/wiki/Donald_Knuth)
- TIOBE Index. (2024). [https://www.tiobe.com/tiobe-index/](https://www.tiobe.com/tiobe-index/)
- Wikipedia. (2024). _Navaja de Ockham_. [https://es.wikipedia.org/wiki/Navaja_de_Ockham](https://es.wikipedia.org/wiki/Navaja_de_Ockham)
- Wikipedia. (2024). _Divide y vencer√°s_. [https://es.wikipedia.org/wiki/Divide_y_vencer%C3%A1s](https://es.wikipedia.org/wiki/Divide_y_vencer%C3%A1s)

---

# Referencias II

- Lenguaje Latino. (2015). [https://www.lenguajelatino.org/](https://www.lenguajelatino.org/)
- Wikipedia. (2024). _Duck typing_. [https://es.wikipedia.org/wiki/Duck_typing](https://es.wikipedia.org/wiki/Duck_typing)
- Wikipedia. (2024). _Pseudoc√≥digo_. [https://es.wikipedia.org/wiki/Pseudoc%C3%B3digo](https://es.wikipedia.org/wiki/Pseudoc%C3%B3digo)
- Scratch. (2024). [https://scratch.mit.edu/](https://scratch.mit.edu/)
- International Organization for Standardization. (2019). _ISO 5807:1985_. [https://www.iso.org/es/contents/data/standard/01/19/11955.html](https://www.iso.org/es/contents/data/standard/01/19/11955.html)
- Excalidraw. (2024). [https://excalidraw.com/](https://excalidraw.com/)
- Draw.io. (2024). [https://app.diagrams.net/](https://app.diagrams.net/)

---

# Referencias III

- Lucidchart. (2024). [https://www.lucidchart.com/pages/es](https://www.lucidchart.com/pages/es)
- Microsoft Visio. (2024). [https://www.microsoft.com/es-mx/microsoft-365/visio/flowchart-software](https://www.microsoft.com/es-mx/microsoft-365/visio/flowchart-software)
- Flowgorithm. (2024). [https://www.flowgorithm.org/](https://www.flowgorithm.org/)
- Jhon DeNero. (2024). _Composing Programs: Designing Functions_. [https://www.composingprograms.com/pages/14-designing-functions.html](https://www.composingprograms.com/pages/14-designing-functions.html)
